import { initContract } from "@ts-rest/core";
import { map, z } from "zod";
import { extendZodWithOpenApi } from "@anatine/zod-openapi";
import * as Rx from "../rxdefs.js";
import RxUtils from "../rxutils.js";
import { Iso639Set1Codes } from "../iso639-1.js";

extendZodWithOpenApi(z);

const c = initContract();

/** Helper function to generate Zod refinements from a RegExp
 *
 * It promotes the RegExp to be a unicode, entire-string match, if it is
 * not already.
 *
 * It also sets the validation error message attribute from the message parameter.
 *
 * @returns a Zod validator generated by the Zod.string().refine() method
 */
function ZodRegex(rx: RegExp, message: string) {
  return z.string().refine((v: any) => RxUtils.uaon(rx).test(String(v)), {
    message,
  });
}

const Location = z.array(z.number()).min(2).max(2);
const CustomMarkerId = z.number();
const DatasetId = z.string().regex(Rx.UrlSafeBase64);
const DatasetItem = z.object({}).passthrough();
const DatasetLocations = z.array(
  Location.nullable(),
  CustomMarkerId.nullable(),
);
const NCName = ZodRegex(Rx.NCName, "Invalid NCName format");
const QName = ZodRegex(Rx.QName, "Invalid QName format");
const DatasetItemId = ZodRegex(
  Rx.DatasetItemId,
  "Invalid DatasetItemId format",
);
const DatasetItemIx = ZodRegex(
  Rx.DatasetItemIx,
  "Invalid DatasetItemIx format",
);
const DatasetItemIdOrIx = ZodRegex(
  Rx.DatasetItemIdOrIx,
  "Invalid DatasetItemIdOrIx format",
);
// Developer note: PrefixUri is regex based, as it attempts to avoid the .url() deficiencies in
// https://github.com/colinhacks/zod/issues/2236. But also our concept of a URI is narrowed, see
// documentation for Rx.PrefixUri.
const PrefixUri = ZodRegex(Rx.PrefixUri, "Invalid prefix URI format");
const PrefixIndex = z.record(PrefixUri, NCName);
const AbbrevUri = ZodRegex(Rx.AbbrevUri, "Invalid abbreviated URI format");

// Zod.enum needs some hand-holding to be happy with using object keys, as it wants a
// guaranteed non-zero length list
const [lang0, ...langs] = Object.keys(Iso639Set1Codes);
const Iso639Set1Code = z.enum([lang0, ...langs]);
const VocabDef = z.object({
  title: z.string(),
  terms: z.record(NCName, z.string()),
});
const I18nVocabDef = z.record(Iso639Set1Code, VocabDef);
const VocabIndex = z.record(NCName, I18nVocabDef);

// The following specs shoud match the types in prop-spec.ts
const FilterSpec = z.object({ preset: z.literal(true), to: z.unknown() });
const CommonPropSpec = z.object({
  from: z.string().optional(),
  titleUri: QName.optional(),
  filter: z.union([FilterSpec, z.boolean()]).optional(),
  search: z.boolean().optional(),
});
const InnerValuePropSpec = z.object({
  type: z.literal("value"),
  as: z
    .union([z.literal("string"), z.literal("boolean"), z.literal("number")])
    .optional(),
  strict: z.boolean().optional(),
  nullable: z.boolean().optional(),
});
const InnerVocabPropSpec = z.object({
  type: z.literal("vocab"),
  uri: AbbrevUri,
  /**
   * Indicates whether the options should be sorted in filter dropdowns.
   * If set to false, no sorting will occur.
   * Sorting is set to 'asc' by default
   * If set to 'asc' or 'desc', the options will be sorted accordingly.
   */
  sorted: z
    .union([z.boolean(), z.literal("asc"), z.literal("desc")])
    .optional(),
});
const InnerPropSpec = z.union([InnerValuePropSpec, InnerVocabPropSpec]);
const OuterMultiPropSpec = z.object({
  type: z.literal("multi"),
  of: InnerPropSpec,
});
const ValuePropSpec = CommonPropSpec.merge(InnerValuePropSpec);
const VocabPropSpec = CommonPropSpec.merge(InnerVocabPropSpec);
const MultiPropSpec = CommonPropSpec.merge(OuterMultiPropSpec);
const PropSpec = z.discriminatedUnion("type", [
  ValuePropSpec,
  VocabPropSpec,
  MultiPropSpec,
]);
const PropSpecs = z.record(z.string(), PropSpec);
const popupItem = z.object({
  itemProp: z.string(),
  valueStyle: z.union([z.literal("text"), z.literal("address"), z.literal("hyperlink")]).default("text"),
  showBullets: z.boolean().default(false).optional(),
  singleColumnLimit: z.number().optional(),
  showLabel: z.boolean().default(false).optional(),
  hyperlinkBaseUri: z.string().default("").optional()
})

const TotalsData = z.record(z.string(), z.number());
const ConfigData = z.object({
  prefixes: PrefixIndex,
  vocabs: VocabIndex,
  itemProps: PropSpecs,
  languages: z.array(Iso639Set1Code).nonempty(),
  ui: z.object({
    directory_panel_field: z.string(),
    marker_property_name: z.string().optional(),
    map: z
      .object({
        mapBounds: z.array(z.array(z.number())).length(2).optional(),
      })
      .optional(),
    logo: z
      .object({
        largeLogo: z.string().optional(),
        smallLogo: z.string().optional(),
        altText: z.string().optional(),
        smallScreenPosition: z
          .object({
            top: z.string().optional(),
            left: z.string().optional(),
          })
          .optional(),
        largeScreenPosition: z
          .object({
            bottom: z.string().optional(),
            right: z.string().optional(),
          })
          .optional(),
      })
      .optional(),
  }),
  popup: z.object({
    titleProp: z.string(),
    "left-pane": z.array(popupItem),
    "top-right-pane": z.array(popupItem),
    "bottom-right-pane": z.array(popupItem)
  }).optional()
});
const BuildInfo = z.object({
  name: z.string(),
  buildTime: z.string().datetime({ offset: false }),
  version: z.array(z.number()).min(1).readonly(),
  commitDesc: z.string(),
  nodeEnv: z.string(),
});
const ErrorInfo = z.object({ message: z.string() }).passthrough();

export const schemas = {
  AbbrevUri,
  Location,
  ConfigData,
  DatasetId,
  DatasetItemId,
  DatasetItemIdOrIx,
  DatasetItemIx,
  DatasetItem,
  DatasetLocations,
  FilterSpec,
  I18nVocabDef,
  Iso639Set1Code,
  MultiPropSpec,
  NCName,
  PrefixUri,
  PrefixIndex,
  PropSpec,
  PropSpecs,
  QName,
  ValuePropSpec,
  BuildInfo,
  VocabDef,
  VocabIndex,
  VocabPropSpec,
  ErrorInfo,
};

export const contract = c.router({
  getDatasetLocations: {
    method: "GET",
    path: "/dataset/:datasetId/locations",
    summary: "obtains a dataset's locations",
    description:
      "Obtains all the locations for a dataset by the dataset ID, which by passing in the appropriate options, might be in different formats",
    pathParams: z.object({
      datasetId: DatasetId.openapi({
        description: "uniquely specifies the dataset wanted",
      }),
    }),
    responses: {
      200: DatasetLocations.openapi({
        description: "the dataset matching the supplied ID",
      }),
      400: ErrorInfo.openapi({
        description: "bad input parameter",
      }),
      404: ErrorInfo.openapi({
        description: "no such dataset",
      }),
    },
  },
  searchDataset: {
    method: "GET",
    path: "/dataset/:datasetId/search",
    summary:
      "obtains a list of dataset entries satisfying the search criteria supplied",
    description:
      "Obtains an array of dataset item indexes, which match the search criteria supplied",
    query: z.object({
      text: z.string().optional().openapi({
        description: "a text fragment to match",
      }),
      // Promote singular parameters to arrays (so that a single filter is possible!),
      // see https://github.com/ts-rest/ts-rest/issues/290#issuecomment-1658983510
      filter: z
        .array(QName)
        .or(QName.transform((v: string) => [v]))
        .optional()
        .openapi({
          description: "uniquely specifies the taxonomy filter items wanted",
        }),
      returnProps: z.array(z.string()).optional().openapi({
        description:
          "The props to return as an array of item objects. If not specified, only an flattened array of indexes is returned.",
      }),
      page: z.coerce.number().int().nonnegative().optional().openapi({
        description:
          "The page number to return. If not specified, all items are returned.",
      }),
      pageSize: z.coerce.number().int().positive().optional().openapi({
        description:
          "The number of items per page. If not specified, all items are returned.",
      }),
    }),
    pathParams: z.object({
      datasetId: DatasetId.openapi({
        description: "uniquely specifies the dataset wanted",
      }),
    }),
    responses: {
      200: z
        .union([
          z.array(DatasetItemIx),
          z.array(DatasetItem.partial().extend({ index: DatasetItemIx })),
        ])
        .openapi({
          description:
            "the dataset item indexes matching the supplied criteria",
        }),
      400: ErrorInfo.openapi({
        description: "bad input parameter",
      }),
      404: ErrorInfo.openapi({
        description: "no such dataset",
      }),
    },
  },
  getDatasetItem: {
    method: "GET",
    path: "/dataset/:datasetId/item/:datasetItemIdOrIx",
    summary: "obtains a dataset item by its unique ID",
    description:
      "Obtains a single dataset item by its ID or its index, and the dataset's ID.",
    pathParams: z.object({
      datasetId: DatasetId.openapi({
        description: "uniquely specifies the dataset wanted",
      }),
      datasetItemIdOrIx: DatasetItemIdOrIx.openapi({
        description:
          "uniquely specifies the dataset item wanted within the dataset",
      }),
    }),
    responses: {
      200: DatasetItem.openapi({
        description: "the dataset item matching the supplied ID or index",
      }),
      400: ErrorInfo.openapi({
        description: "bad input parameter",
      }),
      404: ErrorInfo.openapi({
        description: "no such dataset or dataset item",
      }),
    },
  },
  getTotals: {
    method: "GET",
    path: "/dataset/:datasetId/totals",
    summary: "get the total number of results under each item in the directory",
    description:
      "Gets the total number of results under each item in the directory.",
    pathParams: z.object({
      datasetId: DatasetId.openapi({
        description: "uniquely specifies the dataset wanted",
      }),
    }),
    responses: {
      200: TotalsData.openapi({
        description: "the total result numbers for a map",
      }),
      400: ErrorInfo.openapi({
        description: "bad input parameter",
      }),
      404: ErrorInfo.openapi({
        description: "no such dataset",
      }),
    },
  },
  getConfig: {
    method: "GET",
    path: "/dataset/:datasetId/config",
    summary: "obtain various configured parameters for a dataset",
    description:
      "Obtains configured parameters for a datset, which amongst other things, " +
      "include default values for various options, and definitions of " +
      "vocabulary terms with their localised labels, that are used to " +
      "interpret identifers in the data and/or elsewhere.",
    pathParams: z.object({
      datasetId: DatasetId.openapi({
        description: "uniquely specifies the dataset wanted",
      }),
    }),
    responses: {
      200: ConfigData.openapi({
        description: "various configured parameters for a map",
      }),
      400: ErrorInfo.openapi({
        description: "bad input parameter",
      }),
      404: ErrorInfo.openapi({
        description: "no such dataset",
      }),
    },
  },
  getAbout: {
    method: "GET",
    path: "/dataset/:datasetId/about",
    summary: "obtain the About text for a dataset",
    description:
      "Obtains information about the datset, in markdown format so it can be easily rendered on a front-end application.",
    pathParams: z.object({
      datasetId: DatasetId.openapi({
        description: "uniquely specifies the dataset wanted",
      }),
    }),
    responses: {
      200: z.string().openapi({
        description: "About text in markdown format",
      }),
      400: ErrorInfo.openapi({
        description: "bad input parameter",
      }),
      404: ErrorInfo.openapi({
        description: "no such dataset",
      }),
    },
  },
  getVersion: {
    method: "GET",
    path: "/version",
    summary: "obtains Mykomap server version information",
    description:
      "Obtains version information about the backend Mykomap server, in the form of a JSON object",
    responses: {
      200: BuildInfo.openapi({
        description: "information about the current Mykomap server build",
      }),
    },
  },
});
